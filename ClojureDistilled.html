<html>
<head>
<title>Clojure Distilled</title>
<style>
    body {
        font-family: 'Helvetica Neue', Verdana, Helvetica, Arial, sans-serif;
        max-width: 600px;
        margin: 0 auto;
        padding-top: 72px;
        -webkit-font-smoothing: antialiased;
        font-size: 1.125em;
        color: #333;
        line-height: 1.5em;
    }

    h1, h2, h3, h4, h5, h6 {
        color: #000;
    }

    h1 {
        font-size: 2.5em
    }
    
    h2 {
        font-size: 2em
    }
    
    h3 {
        font-size: 1.5em
    }
    
    h4 {
        font-size: 1.375em
    }
    
    h5 {
        font-size: 1.25em
    }
    
    h6 {
        font-size: 1.125em
    }

    a {
        text-decoration: none;
        color: #09f;
    }

    a:hover {
        text-decoration: underline;
    }
    code {
        border-radius: 5px;
    }
    .hljs{display:block;overflow-x:auto;padding:.5em;background:#f0f0f0}.hljs,.hljs-subst,.hljs-tag .hljs-title,.lisp .hljs-title,.clojure .hljs-built_in,.nginx .hljs-title{color:black}.hljs-string,.hljs-title,.hljs-constant,.hljs-parent,.hljs-tag .hljs-value,.hljs-rules .hljs-value,.hljs-preprocessor,.hljs-pragma,.haml .hljs-symbol,.ruby .hljs-symbol,.ruby .hljs-symbol .hljs-string,.hljs-template_tag,.django .hljs-variable,.smalltalk .hljs-class,.hljs-addition,.hljs-flow,.hljs-stream,.bash .hljs-variable,.apache .hljs-tag,.apache .hljs-cbracket,.tex .hljs-command,.tex .hljs-special,.erlang_repl .hljs-function_or_atom,.asciidoc .hljs-header,.markdown .hljs-header,.coffeescript .hljs-attribute{color:#800}.smartquote,.hljs-comment,.hljs-annotation,.hljs-template_comment,.diff .hljs-header,.hljs-chunk,.asciidoc .hljs-blockquote,.markdown .hljs-blockquote{color:#888}.hljs-number,.hljs-date,.hljs-regexp,.hljs-literal,.hljs-hexcolor,.smalltalk .hljs-symbol,.smalltalk .hljs-char,.go .hljs-constant,.hljs-change,.lasso .hljs-variable,.makefile .hljs-variable,.asciidoc .hljs-bullet,.markdown .hljs-bullet,.asciidoc .hljs-link_url,.markdown .hljs-link_url{color:#080}.hljs-label,.hljs-javadoc,.ruby .hljs-string,.hljs-decorator,.hljs-filter .hljs-argument,.hljs-localvars,.hljs-array,.hljs-attr_selector,.hljs-important,.hljs-pseudo,.hljs-pi,.haml .hljs-bullet,.hljs-doctype,.hljs-deletion,.hljs-envvar,.hljs-shebang,.apache .hljs-sqbracket,.nginx .hljs-built_in,.tex .hljs-formula,.erlang_repl .hljs-reserved,.hljs-prompt,.asciidoc .hljs-link_label,.markdown .hljs-link_label,.vhdl .hljs-attribute,.clojure .hljs-attribute,.asciidoc .hljs-attribute,.lasso .hljs-attribute,.coffeescript .hljs-property,.hljs-phony{color:#88f}.hljs-keyword,.hljs-id,.hljs-title,.hljs-built_in,.css .hljs-tag,.hljs-javadoctag,.hljs-phpdoc,.hljs-yardoctag,.smalltalk .hljs-class,.hljs-winutils,.bash .hljs-variable,.apache .hljs-tag,.go .hljs-typename,.tex .hljs-command,.asciidoc .hljs-strong,.markdown .hljs-strong,.hljs-request,.hljs-status{font-weight:bold}.asciidoc .hljs-emphasis,.markdown .hljs-emphasis{font-style:italic}.nginx .hljs-built_in{font-weight:normal}.coffeescript .javascript,.javascript .xml,.lasso .markup,.tex .hljs-formula,.xml .javascript,.xml .vbscript,.xml .css,.xml .hljs-cdata{opacity:.5}
</style>
</head>
<body>
<div class="article"><h1 id="clojure-distilled">Clojure Distilled</h1>
<p>The difficulty in learning Clojure does not stem from its syntax, which happens to be extremely simple, but from having to learn new methods for solving problems. As such, we'll focus on understanding the core concepts and how they can be combined to solve problems the functional way.</p>
<p>All the mainstream languages belong to the same family. Once you learn one of these languages there is very little effort involved in learning another. Generally, all you have to do is learn some syntax sugar and the useful functions in the standard library to become productive. There might be a new concept here and there, but most of your existing skills are easily transferable.</p>
<p>This is not the case with Clojure. Being a Lisp dialect, it comes from a different family of languages and requires learning new concepts in order to use effectively. There is no reason to be discouraged if the code appears hard to read at first. I assure you that the syntax is not inherently difficult to understand, and that with a bit of practice you might find it to be quite the opposite.</p>
<p>The goal of this guide is to provide an overview of the core concepts necessary to become productive with Clojure. Let's start by examining some of the key advantages of the functional style and why you would want to learn a functional language in the first place.</p>
<h2 id="immutable">Immutable</h2>
<p>Clojure is a functional language. This makes it extremely well positioned for writing large applications. As the application grows it's imperative to be able to reason about its constituent parts in isolation. Conversely, there is a lot of value in building code out of components that are testable and reusable by nature. Let's take a look at why the functional approach is such a good fit here.</p>
<p>Functional languages are ideal for writing large applications because they eschew global state and favor immutability as the default. Having immutable shared state allows us to safely reason about parts of the application in isolation. At first glance, the idea of using immutable data structures sounds unnecessarily restrictive. However, as we'll soon see, many of the benefits associated with the functional style stem directly from it.</p>
<p>Mutable data can either be passed around by value or by reference. The safe approach would be to pass the data by value as it guarantees that any changes to the data will remain in the local scope. Unfortunately, this approach is extremely inefficient, so most languages pass data by reference instead.</p>
<p>Passing data by reference is fast, but it makes the code difficult to reason about. In order to safely work with the data you have to know all the places where it might be referenced. The complexity grows with the size of the application. The more code has access to a piece of data the more proverbial balls you end up having to juggle in your head.</p>
<p>Immutable data structures provide us with an ingenious alternative to the above dilemma. Every time a change is made to the data structure a revision is created. We now have the same guarantees offered by naive copying of the data, but we only pay the price proportional to the size of the change.</p>
<p>Just like garbage collection frees us from having to manually track data allocation and deallocation, immutable data structures free us from having to manage data references by hand. From the user perspective we simply "copy" the data any time we make a change. The language will take care of figuring out what parts of it can be cleaned up when they're no longer used.</p>
<p>Having such data structures facilitates writing pure functions. A pure function is simply a function without side effects. These functions do not rely on any state outside their inputs and they do not modify any external state when they run. Given the same parameters, the function will always produce the same result, regardless of the global state of the application.</p>
<p>Such functions can be safely reasoned about in isolation because we can guarantee that they're only able to modify their local scope. They provide us with self-contained components that can be composed to create complex behaviors. This type of code is referred to as being referentially transparent.</p>
<h2 id="reusable">Reusable</h2>
<p>Object-oriented languages use classes for composition. The data in each class is tightly coupled to the logic associated with it. Each class represents a specific domain and the methods written in it are not easily reusable outside that domain. When we wish to reuse the existing code we often have to resort to patterns such as adapters and wrappers.</p>
<p>The focus, in such a language, is primarily on modeling the state using classes. The data is seen as being incidental to the whole process. Functional programming brings data to the forefront and it encourages us to think about our problems in terms of data transformations.</p>
<p>In a functional language, the logic and the data are kept separate. Clojure provides a small set of common data structures such as lists, vectors, maps, and sets. All the functions in the language operate on the same data structures allowing us to combine them without any additional ceremony. With this approach the function becomes the core reusable component.</p>
<p>Each function represents a certain transformation that we wish to apply to our data. When we need to solve a problem we simply have to break it up into a sequence of transformations and map those to the appropriate functions. The functions capture how the tasks are accomplished, while their composition states what is being accomplished. Code that separates what is being done from how it is done is referred to as being declarative.</p>
<p>Let's take iteration as an example. With the imperative style we would write a loop and put the logic that's invoked during each step inside it. By contrast, the functional approach is to use an iterator function and pass the logic that we want to execute during the iteration as a parameter.</p>
<p>An iterator function can be written once and it encapsulates all the logic required for iteration, edge cases, and boundary checks. We can now reuse this function without having to worry about remembering to do these checks each time we need to iterate.</p>
<h2 id="scalable">Scalable</h2>
<p>The focus on immutability makes it much easier to tackle the difficult problems of parallelism and concurrency. While there is no silver bullet for addressing either problem, the language can go a long way in  helping us reason about them.</p>
<p>As you'll recall, pure functions rely solely on their arguments and do not modify any state outside their scope. These properties make it possible to safely run them in parallel allowing us to easily take advantage of the extra cores.</p>
<p>An example of this is mapping a function over the items in a collection. We can start by using the <code>map</code> function. This function will iterate over a collection and apply a transformer function to each element inside it. Should we discover that each operation takes a significant amount of time, we can then simply switch to using the <code>pmap</code> function to run these operations in parallel.</p>
<p>Finally, it turns out that the immutable data structures are also an excellent tool for managing shared mutable state. Clojure provides a Software Transactional Memory (STM) library based on these data structures. With transactional memory we no longer have to worry about manual locking when dealing with threads. Better still, shared state backed by immutable data only needs to be locked for writing since the current revision can be safely read while the new revision is being generated.</p>
<h1 id="clojure-in-action">Clojure In Action</h1>
<p>Now that we've discussed some of the reasons to start using the functional style, let's see how to apply these ideas in practice with Clojure.</p>
<h2 id="the-core">The Core</h2>
<h3 id="data-types">Data Types</h3>
<p>Clojure provides a number of standard data types, most of which should look familiar:</p>
<ul>
<li>Vars provide mutable storage locations. These can be bound and rebound on a per-thread basis.</li>
<li>Booleans can have a value of true or false; nil values are also treated as false.</li>
<li>Numbers can be integers, doubles, floats, and fractions.</li>
<li>Symbols are used as identifiers for variables.</li>
<li>Keywords are symbols that reference themselves and are denoted by a colon; these are often used as keys in maps.</li>
<li>Strings are denoted by double quotes and can span multiple lines.</li>
<li>Characters are denoted by a backslash.</li>
<li>Regular expressions are strings prefixed with a hash symbol.</li>
</ul>
<p>In addition to the data types, Clojure provides us with a literal notation for common collection types such as lists, vectors, maps, and sets:</p>
<ul>
<li>List: <code>'(1 2 3)</code></li>
<li>Vector: <code>[1 2 3]</code></li>
<li>Map: <code>{:foo "a" :bar "b"}</code></li>
<li>Set: <code>#{"a" "b" "c"}</code></li>
</ul>
<p>Interestingly, Clojure logic is written using its data structures. Using the same syntax for both data and logic allows for powerful metaprogramming features. We can manipulate any piece of Clojure code just like we would any other data structure. This feature makes it trivial to template the code for recurring patterns in your problem domain. In Clojure, code is data and data is code.</p>
<h3 id="special-forms">Special Forms</h3>
<p>Special forms provide a small set of primitives, such as the <code>if</code> conditional, that define the core syntax. These are akin to reserved keywords found in other languages. However, unlike most languages, Clojure uses a minimal amount of reserved syntax and majority of the language is implemented using functions and macros in the standard library.</p>
<h2 id="functions">Functions</h2>
<p>Function calls in Clojure work the same as any mainstream languages. The main difference being that the function name comes after the paren in the Clojure version.</p>
<pre><code class="lang-python hljs ">functionName(param1, param2)
</code></pre>
<pre><code class="lang-clojure hljs "><span class="hljs-list">(<span class="hljs-title">function-name</span> param1 param2)</span>
</code></pre>
<p>There is a very simple reason for this difference. The function call is simply a list containing the function name and its parameters. In Clojure, a list is a special type of data structure reserved for creating callable expressions. To create a list data structure we'd have to call the list function:</p>
<pre><code class="lang-clojure hljs "><span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">list</span></span><span class="hljs-number"> 1</span><span class="hljs-number"> 2</span><span class="hljs-number"> 3</span>)</span>
</code></pre>
<h3 id="anonymous-functions">Anonymous Functions</h3>
<p>As the name implies, anonymous functions are simply functions that aren't bound to a name. Let's take a look at the following function that accepts a single argument and prints it:</p>
<pre><code class="lang-clojure hljs "><span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">fn</span></span> <span class="hljs-collection">[arg]</span> <span class="hljs-list">(<span class="hljs-title">println</span> arg)</span>)</span>
</code></pre>
<p>The function is defined by using the <code>fn</code> form followed by the vector containing its argument and the body. We could call the above function by setting it as a first item in a list and its argument as the second:</p>
<pre><code class="lang-clojure hljs "><span class="hljs-list">(<span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">fn</span></span> <span class="hljs-collection">[arg]</span> <span class="hljs-list">(<span class="hljs-title">println</span> arg)</span>)</span> <span class="hljs-string">"hello"</span>)</span>
=&gt;"hello"
</code></pre>
<p>Clojure provides syntactic sugar for defining anonymous functions using the <code>#</code> notation. With it we can rewrite our function more concisely as follows:</p>
<pre><code class="lang-clojure hljs ">#<span class="hljs-list">(<span class="hljs-title">println</span> %)</span>
</code></pre>
<p>Here, the <code>%</code> symbol indicates an unnamed argument. Multiple arguments would each be followed by a number indicating its position as seen below:</p>
<pre><code class="lang-clojure hljs ">#<span class="hljs-list">(<span class="hljs-title">println</span> %1 %2 %3)</span>
</code></pre>
<p>This type of function is useful when you need to perform a one-off computations that don't warrant defining a named function. They are commonly used in conjunction with the higher-order functions that we'll see in a moment.</p>
<h3 id="named-functions">Named Functions</h3>
<p>Named functions are simply anonymous functions bound to a symbol used as an identifier. Clojure provides a special form called <code>def</code> that's used for creating global variables. It accepts a name and the body to be assigned to it. We can create a named function using the <code>def</code> form as follows:</p>
<pre><code class="lang-clojure hljs "><span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">def</span></span> double
  <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">fn</span></span> <span class="hljs-collection">[x]</span> <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">*</span></span><span class="hljs-number"> 2</span> x)</span>)</span>)</span>
</code></pre>
<p>Since this is such a common operation, Clojure provides a form called <code>defn</code> that does it for us:</p>
<pre><code class="lang-clojure hljs "><span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">defn</span></span> square <span class="hljs-collection">[x]</span>
  <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">*</span></span> x x)</span>)</span>
</code></pre>
<p>The <code>defn</code> form behaves the same as the <code>fn</code> form we saw above, except that its first argument is the name of the function. The body of the function can consist of multiple expressions:</p>
<pre><code class="lang-clojure hljs "><span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">defn</span></span> bmi <span class="hljs-collection">[height weight]</span>
  <span class="hljs-list">(<span class="hljs-title">println</span> <span class="hljs-string">"height:"</span> height)
  (<span class="hljs-title">println</span> <span class="hljs-string">"weight:"</span> weight)
  (/ weight (* height height)))
</span></span></span></code></pre>
<p>Here we define a function to calculate the BMI using the height and weight parameters. The body consists of two print statements and a call to divide the weight by the square of the height. All the expressions are evaluated from the inside out. In the last statement, <code>(* height height)</code> is evaluated, then the weight is divided by the result and returned. In Clojure, mathematical operators, such as <code>/</code> and <code>*</code>, are regular functions and so we call them using the prefix notation as we would with any other function.</p>
<p>Note that only the result from the last expression is returned from the function, the results of all the other expressions are discarded. Therefore, any intermediate expressions should strictly be used for side effects as is the case with the <code>println</code> calls above.</p>
<p>One thing to note is that Clojure uses a single pass compiler. For this reason, the functions must be declared before they are used. In a case when we need to refer to a function before it's been declared, we must use the <code>declare</code> macro in order to provide a forward declaration.</p>
<pre><code class="lang-clojure hljs "><span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">declare</span></span> down)</span>

<span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">defn</span></span> up <span class="hljs-collection">[n]</span>
  <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">if</span></span> <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">&lt;</span></span> n<span class="hljs-number"> 10</span>)</span>
    <span class="hljs-list">(<span class="hljs-title">down</span> <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">+</span></span><span class="hljs-number"> 2</span> n)</span>)</span> n)</span>)</span>

<span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">defn</span></span> down <span class="hljs-collection">[n]</span>
  <span class="hljs-list">(<span class="hljs-title">up</span> <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">dec</span></span> n)</span>)</span>)</span>
</code></pre>
<p>A keen reader will have noticed that the code is structured as a tree. This tree is called the abstract syntax tree, or AST for short. By being able to see the AST directly, we can examine the relationships between pieces of logic visually.</p>
<p>Since we write our code in terms of data, there are fewer syntactic hints than in most languages. For example, there is no explicit return statement and the last expression of the function body is returned implicitly.</p>
<p>This might take a little getting used to if you're accustomed to seeing a lot of annotations in your code. To aid readability, functions are often kept short while indentation and spacing are used for grouping code visually.</p>
<p>In Clojure, there is no distinction between functions and variables. You can assign a function to a label, pass it as a parameter, or return a function from another function. Functions that can be treated as data are referred to as being first-class because they don't have any additional restrictions attached to them.</p>
<h3 id="higher-order-functions">Higher-Order Functions</h3>
<p>Functions that take other functions as parameters are called higher-order functions. One example of such a function is <code>map</code>:</p>
<pre><code class="lang-clojure hljs "><span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">map</span></span> #<span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">*</span></span> % %)</span> <span class="hljs-collection">[<span class="hljs-number">1 2 3 4 5</span>]</span>)</span> =&gt; <span class="hljs-list">(<span class="hljs-number">1 4 9 16 25</span>)</span>
</code></pre>
<p>This function accepts two parameters where the first is an anonymous function that squares its argument and the second is a collection of numbers. The map function will visit each item in the collection and square it.</p>
<p>One major advantage of using a higher order function is that we can infer the intent of the code from the function being used. Let's contrast the above example to an imperative style loop:</p>
<pre><code class="lang-clojure hljs "><span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">loop</span></span> <span class="hljs-collection">[<span class="hljs-collection">[n &amp; numbers]</span> <span class="hljs-collection">[1<span class="hljs-number"> 2</span><span class="hljs-number"> 3</span><span class="hljs-number"> 4</span><span class="hljs-number"> 5</span>]</span>
       result <span class="hljs-collection">[]</span>]</span>
  <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">let</span></span> <span class="hljs-collection">[result <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">conj</span></span> result <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">*</span></span> n n)</span>)</span>]</span>
    <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">if</span></span> numbers
      <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">recur</span></span> numbers result)</span>
      result)</span>)</span>)</span>
</code></pre>
<p>The looping approach ends up having a lot more noise and thus we have to read through the code more carefully to tell what it's doing. The other problem is that the code becomes monolithic and no part of it can be used individually.</p>
<p>Another example of a higher-order function is <code>filter</code>. This function goes through a collection and keeps only the items matching the specified predicate.</p>
<pre><code class="lang-clojure hljs "><span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">filter</span></span> even? <span class="hljs-collection">[<span class="hljs-number">1 2 3 4 5</span>]</span>)</span> =&gt; <span class="hljs-list">(<span class="hljs-number">2 4</span>)</span>
</code></pre>
<p>Higher order functions can be easily chained together to create complex transformations:</p>
<pre><code class="lang-clojure hljs "><span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">filter</span></span> even?
  <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">map</span></span> #<span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">*</span></span><span class="hljs-number"> 3</span> %)</span> <span class="hljs-collection">[<span class="hljs-number">1 2 3 4 5</span>]</span>)</span>)</span>

=&gt;<span class="hljs-list">(<span class="hljs-number">6 12</span>)</span>
</code></pre>
<p>Here we multiply each item by 3, then we use <code>filter</code> to only keep the even items from the resulting sequence. Having higher-order functions means that you should rarely have to write loops or explicit recursion. When iterating a collection, use a function such as <code>map</code> or <code>filter</code> instead. Since Clojure has a rich standard library, practically any data transformation can be easily achieved by combining functions found there. See <a href="https://github.com/mythz/clojure-linq-examples">here</a> for some examples of this approach in action.</p>
<p>Once you learn to associate data transformations with specific functions, many problems can be solved by simply putting these functions together in a specific order.</p>
<p>Let's take a look at using this idea for a simple real world problem. We'd like to display a formatted address given the fields representing it. Commonly an address has a unit number, a street, a city, a postal code, and a country. We'll have to examine each of these fields, remove the <code>nil</code> and empty ones, and insert a separator between them. Given a table containing the following fields:</p>
<pre><code class=" hljs 1c">unit      <span class="hljs-string">| street          | city      | postal_code | country</span>
<span class="hljs-string">""</span>        <span class="hljs-string">| "</span><span class="hljs-number">1</span> Main street<span class="hljs-string">" | "</span>Toronto<span class="hljs-string">" | nil         | "</span>Canada<span class="hljs-string">"</span>
</code></pre><p>We would like to output the following formatted string using the strings in the table:</p>
<pre><code class=" hljs bash"><span class="hljs-string">"1 Main street, Toronto, Canada"</span>
</code></pre><p>All we have to do is find the functions for the tasks of removing empty fields, interposing the separator, and concatenating the result into a string:</p>
<pre><code class="lang-clojure hljs "><span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">defn</span></span> concat-fields <span class="hljs-collection">[&amp; fields]</span>
  <span class="hljs-list">(<span class="hljs-title">clojure.string/join</span> <span class="hljs-string">", "</span> <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">remove</span></span> empty? fields)</span>)</span>)</span>

<span class="hljs-list">(<span class="hljs-title">concat-fields</span> <span class="hljs-string">""</span> <span class="hljs-string">"1 Main street"</span> <span class="hljs-string">"Toronto"</span> <span class="hljs-literal">nil</span> <span class="hljs-string">"Canada"</span>)</span>
<span class="hljs-prompt">=&gt; </span>"1 Main street, Toronto, Canada"
</code></pre>
<p>Notice that we didn't have to specify how to do any of the tasks when writing our code. Most of the time we simply say what we're doing by composing the functions representing the operations we wish to carry out. The resulting code also handles all the common edge cases:</p>
<pre><code class="lang-clojure hljs "><span class="hljs-list">(<span class="hljs-title">concat-fields</span>)</span> =&gt; ""
<span class="hljs-list">(<span class="hljs-title">concat-fields</span> <span class="hljs-literal">nil</span>)</span> =&gt; ""
<span class="hljs-list">(<span class="hljs-title">concat-fields</span> <span class="hljs-string">""</span>)</span> =&gt; ""
</code></pre>
<p>In Clojure, it's common for the code to work correctly for all inputs out of the box.</p>
<h3 id="closures">Closures</h3>
<p>We've now seen how we can declare functions, name them, and pass them as parameters to other functions. One last thing we can do is write functions that return other functions as their result. One use for such functions is to provide the functionality facilitated by constructors in object-oriented languages.</p>
<p>Let's say we wish to greet our guests with a warm greeting. We can write a function that will accept the greeting string as its parameter and return a function that takes the name of the guest and prints a customized greeting for that guest:</p>
<pre><code class="lang-clojure hljs "><span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">defn</span></span> greeting <span class="hljs-collection">[greeting-string]</span>
  <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">fn</span></span> <span class="hljs-collection">[guest]</span>
    <span class="hljs-list">(<span class="hljs-title">println</span> greeting-string guest)</span>)</span>)</span>

<span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">let</span></span> <span class="hljs-collection">[greet <span class="hljs-list">(<span class="hljs-title">greeting</span> <span class="hljs-string">"Welcome to the wonderful world of Clojure"</span>)</span>]</span>
  <span class="hljs-list">(<span class="hljs-title">greet</span> <span class="hljs-string">"Jane"</span>)</span>
  <span class="hljs-list">(<span class="hljs-title">greet</span> <span class="hljs-string">"John"</span>)</span>)</span>
</code></pre>
<p>The inner function in the <code>greeting</code> has access to the <code>greeting-string</code> value since the value is defined in its outer scope. The <code>greeting</code> function is called a closure because it closes over its parameters, in our case the <code>greeting-string</code>, and makes them available to the function that it returns.</p>
<p>You'll also notice that we're using a form called <code>let</code> to bind the <code>greet</code> symbol and make it available to any expressions inside it. The <code>let</code> form serves the same purpose as declaring variables in imperative languages.</p>
<h3 id="threading-expressions">Threading Expressions</h3>
<p>By this point you're probably noticing that nested expressions can get difficult to read. Fortunately, Clojure provides a couple of helper forms to deal with this problem. Let's say we have a range of numbers, and we want to increment each number, interpose the number 5 between them, then sum the result. We could write the following code to do that:</p>
<pre><code class="lang-clojure hljs "><span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">reduce</span></span> + <span class="hljs-list">(<span class="hljs-title">interpose</span><span class="hljs-number"> 5</span> <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">map</span></span> inc <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">range</span></span><span class="hljs-number"> 10</span>)</span>)</span>)</span>)</span>
</code></pre>
<p>It's a little difficult to tell what's happening above at a glance. With a few more steps in the chain we'd be really lost. On top of that, if we wanted to rearrange any of the steps, such as interposing 5 before incrementing, then we'd have to renest all our expressions. An alternative way to write the above expression is to use the <code>-&gt;&gt;</code> form:</p>
<pre><code class="lang-clojure hljs "><span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">-&gt;&gt;</span></span> <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">range</span></span><span class="hljs-number"> 10</span>)</span> <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">map</span></span> inc)</span> <span class="hljs-list">(<span class="hljs-title">interpose</span><span class="hljs-number"> 5</span>)</span> <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">reduce</span></span> +)</span>)</span>
</code></pre>
<p>Here, we use <code>-&gt;&gt;</code> to thread the operations from one to the next. This means that we implicitly pass the result of each expression as the last argument of the next expression. To pass it as the first argument we'd use the <code>-&gt;</code> form instead.</p>
<h3 id="laziness">Laziness</h3>
<p>Many Clojure algorithms use lazy evaluation where the operations aren't performed unless their result actually needs to be evaluated. Laziness is crucial for making many algorithms work efficiently. For example, you might think the preceding example is very inefficient since we have to iterate our sequence each time to create the range, map across it, interpose the numbers, and reduce the result.</p>
<p>However, this is not actually the case. The evaluation of each expression happens on demand. The first value in the range is generated and passed to the rest of the functions, then the next, and so on, until the sequence is exhausted. This is a similar approach that languages like Python take with their iterator mechanics.</p>
<h2 id="code-structure">Code Structure</h2>
<p>One nontrivial difference between Clojure and imperative languages is the way the code is structured. In imperative style, it's a common pattern to declare a shared mutable variable and modify it by passing it different functions. Each time we access the memory location we see the result of the code that previously worked with it. For example, if we have a list of integers and we wish to square each one then print the even ones, the following Python code would be perfectly valid:</p>
<pre><code class="lang-python hljs ">l = <span class="hljs-keyword">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>)

<span class="hljs-keyword">for</span> i, val <span class="hljs-keyword">in</span> enumerate(l) :
  l[i] = val * val

<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> l :
  <span class="hljs-keyword">if</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> :
    <span class="hljs-keyword">print</span> i
</code></pre>
<p>In Clojure this interaction has to be made explicit. Instead of creating a shared memory location and then having different functions access it sequentially, we chain functions together and pipe the input through them:</p>
<pre><code class="lang-clojure hljs "><span class="hljs-list">(<span class="hljs-title">println</span>
  <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">filter</span></span> #<span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">=</span></span> <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">mod</span></span> %<span class="hljs-number"> 2</span>)</span><span class="hljs-number"> 0</span>)</span>
    <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">map</span></span> #<span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">*</span></span> % %)</span> <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">range</span></span><span class="hljs-number"> 1</span><span class="hljs-number"> 6</span>)</span>)</span>)</span>)</span>
</code></pre>
<p>We could also flatten out the steps using the <code>-&gt;&gt;</code> macro introduced earlier:</p>
<pre><code class="lang-clojure hljs "><span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">-&gt;&gt;</span></span> <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">range</span></span><span class="hljs-number"> 1</span><span class="hljs-number"> 6</span>)</span>
     <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">map</span></span> #<span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">*</span></span> % %)</span>)</span>
     <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">filter</span></span> #<span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">=</span></span> <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">mod</span></span> %<span class="hljs-number"> 2</span>)</span><span class="hljs-number"> 0</span>)</span>)</span>
     <span class="hljs-list">(<span class="hljs-title">println</span>)</span>)</span>
</code></pre>
<p>Each function returns a new value instead of modifying the existing data in place. You might think that this can get very expensive, and it would be with a na&iuml;ve implementation where the entirety of the data is copied with every change.</p>
<p>In reality, Clojure is backed by persistent data structures that create in-memory revisions of the data. Each time a change is made a new revision is created proportional to the size of the change. With this approach we only pay the price of the difference between the old and the new structures while ensuring that any changes are localized.</p>
<h3 id="destructuring">Destructuring</h3>
<p>Clojure has a powerful mechanism called destructuring for declaratively accessing values in data structures. This technique provides easy access to the data and serves to document the parameters to a function. Let's look at some examples to see how it works.</p>
<pre><code class="lang-clojure hljs "><span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">let</span></span> <span class="hljs-collection">[<span class="hljs-collection">[smaller bigger]</span> <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">split-with</span></span> #<span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">&lt;</span></span> %<span class="hljs-number"> 5</span>)</span> <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">range</span></span><span class="hljs-number"> 10</span>)</span>)</span>]</span>
    <span class="hljs-list">(<span class="hljs-title">println</span> smaller bigger)</span>)</span>

=&gt;<span class="hljs-list">(<span class="hljs-title">0</span><span class="hljs-number"> 1</span><span class="hljs-number"> 2</span><span class="hljs-number"> 3</span><span class="hljs-number"> 4</span>)</span> <span class="hljs-list">(<span class="hljs-title">5</span><span class="hljs-number"> 6</span><span class="hljs-number"> 7</span><span class="hljs-number"> 8</span><span class="hljs-number"> 9</span>)</span>
</code></pre>
<p>Above, we use <code>split-with</code> function to split a range of ten numbers into a sequence containing two elements: numbers less than 5 and numbers greater than or equal to 5. Since we know the format of the result, we can write it in a literal form as <code>[smaller bigger]</code> in the <code>let</code> binding. Destructuring is not limited to the <code>let</code> form and works for all types of bindings such as function arguments.</p>
<p>Let's look at another function called <code>print-user</code> that accepts a vector with three elements and binds them to <code>name</code>, <code>address</code>, and <code>phone</code>, respectively:</p>
<pre><code class="lang-clojure hljs "><span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">defn</span></span> print-user <span class="hljs-collection">[<span class="hljs-collection">[name address phone]</span>]</span>
  <span class="hljs-list">(<span class="hljs-title">println</span> name <span class="hljs-string">"-"</span> address phone)</span>)</span>

<span class="hljs-list">(<span class="hljs-title">print-user</span> <span class="hljs-collection">[<span class="hljs-string">"John"</span> <span class="hljs-string">"397 King street, Toronto"</span> <span class="hljs-string">"416-936-3218"</span>]</span>)</span>
<span class="hljs-prompt">=&gt; </span>"John - 397 King street, Toronto 416-936-3218"
</code></pre>
<p>We can also specify variable arguments as a sequence. This is done by using <code>&amp;</code> followed by the name of the list containing the remaining arguments:</p>
<pre><code class="lang-clojure hljs "><span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">defn</span></span> print-args <span class="hljs-collection">[&amp; args]</span>
  <span class="hljs-list">(<span class="hljs-title">println</span> args)</span>)</span>

<span class="hljs-list">(<span class="hljs-title">print-args</span> <span class="hljs-string">"a"</span> <span class="hljs-string">"b"</span> <span class="hljs-string">"c"</span>)</span> =&gt; <span class="hljs-list">(<span class="hljs-title">a</span> b c)</span>
</code></pre>
<p>Since the variable arguments are stored in a sequence, it can be destructured like any other:</p>
<pre><code class="lang-clojure hljs "><span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">defn</span></span> print-args <span class="hljs-collection">[arg1 &amp; <span class="hljs-collection">[arg2]</span>]</span>
  <span class="hljs-list">(<span class="hljs-title">println</span>
    <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">if</span></span> arg2
      <span class="hljs-string">"got two arguments"</span>
      <span class="hljs-string">"got one argument"</span>)</span>)</span>)</span>

<span class="hljs-list">(<span class="hljs-title">print-args</span> <span class="hljs-string">"bar"</span>)</span>
=&gt;"got one argument"

<span class="hljs-list">(<span class="hljs-title">print-args</span> <span class="hljs-string">"bar"</span> <span class="hljs-string">"baz"</span>)</span>
=&gt;"got two arguments"
</code></pre>
<p>Destructuring can also be applied to maps. When destructuring a map, we create a new map where we supply the names for the local bindings pointing to the keys from the original map:</p>
<pre><code class="lang-clojure hljs "><span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">let</span></span> <span class="hljs-collection">[<span class="hljs-collection">{foo <span class="hljs-attribute">:foo</span> bar <span class="hljs-attribute">:bar</span>}</span> <span class="hljs-collection">{<span class="hljs-attribute">:foo</span> <span class="hljs-string">"foo"</span> <span class="hljs-attribute">:bar</span> <span class="hljs-string">"bar"</span>}</span>]</span>
  <span class="hljs-list">(<span class="hljs-title">println</span> foo bar)</span>
</span></code></pre>
<p>It's also possible to destructure a nested data structure. As long as you know the structure of the data being passed in, you can simply write it out:</p>
<pre><code class=" hljs clojure"><span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">let</span></span> <span class="hljs-collection">[<span class="hljs-collection">{<span class="hljs-collection">[a b c]</span> <span class="hljs-attribute">:items</span> id <span class="hljs-attribute">:id</span>}</span> <span class="hljs-collection">{<span class="hljs-attribute">:id</span> <span class="hljs-string">"foo"</span> <span class="hljs-attribute">:items</span> <span class="hljs-collection">[1<span class="hljs-number"> 2</span><span class="hljs-number"> 3</span>]</span>}</span>]</span>
  <span class="hljs-list">(<span class="hljs-title">println</span> id <span class="hljs-string">"-&gt;"</span> a b c)</span>)</span>
<span class="hljs-prompt">=&gt; </span>"foo -&gt; 1 2 3"
</code></pre><p>Finally, since extracting keys from maps is a very common operation, Clojure provides syntactic sugar for this task:</p>
<pre><code class="lang-clojure hljs "><span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">defn</span></span> login <span class="hljs-collection">[<span class="hljs-collection">{<span class="hljs-attribute">:keys</span> <span class="hljs-collection">[user pass]</span>}</span>]</span>
 <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">and</span></span> <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">=</span></span> user <span class="hljs-string">"bob"</span>)</span> <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">=</span></span> pass <span class="hljs-string">"secret"</span>)</span>)</span>)</span>

<span class="hljs-list">(<span class="hljs-title">login</span> <span class="hljs-collection">{<span class="hljs-attribute">:user</span> <span class="hljs-string">"bob"</span> <span class="hljs-attribute">:pass</span> <span class="hljs-string">"secret"</span>}</span>)</span>
</code></pre>
<p>Another useful destructuring option allows us to extract some keys while preserving the original map:</p>
<pre><code class="lang-clojure hljs "><span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">defn</span></span> register <span class="hljs-collection">[<span class="hljs-collection">{<span class="hljs-attribute">:keys</span> <span class="hljs-collection">[id pass repeat-pass]</span> <span class="hljs-attribute">:as</span> user}</span>]</span>
  <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">cond</span></span>
    <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">nil?</span></span> id)</span> <span class="hljs-string">"user id is required"</span>
    <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">not=</span></span> pass repeat-pass)</span> <span class="hljs-string">"re-entered password doesn't match"</span>
    <span class="hljs-attribute">:else</span> user)</span>)</span>
</code></pre>
<h3 id="namespaces">Namespaces</h3>
<p>When writing real-world applications we need tools to organize our code into separate components. Object-oriented languages provide classes for this purpose. The related methods will all be defined in the same class. In Clojure, we group our functions into namespaces instead. Let's look at how a namespace is defined.</p>
<pre><code class="lang-clojure hljs "><span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">ns</span></span> colors)</span>

<span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">defn</span></span> hex-&gt;rgb <span class="hljs-collection">[<span class="hljs-collection">[_ &amp; rgb]</span>]</span>
    <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">map</span></span> #<span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">-&gt;&gt;</span></span> % <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">apply</span></span> str <span class="hljs-string">"0x"</span>)</span> <span class="hljs-list">(<span class="hljs-title">Long/decode</span>)</span>)</span>
         <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">partition</span></span><span class="hljs-number"> 2</span> rgb)</span>)</span>)</span>

<span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">defn</span></span> hex-str <span class="hljs-collection">[n]</span>
  <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">-&gt;</span></span> <span class="hljs-list">(<span class="hljs-title">format</span> <span class="hljs-string">"%2s"</span> <span class="hljs-list">(<span class="hljs-title">Integer/toString</span> n<span class="hljs-number"> 16</span>)</span>)</span>
      <span class="hljs-list">(<span class="hljs-title">clojure.string/replace</span> <span class="hljs-string">" "</span> <span class="hljs-string">"0"</span>)</span>)</span>)</span>

<span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">defn</span></span> rgb-&gt;hex <span class="hljs-collection">[color]</span>
  <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">apply</span></span> str <span class="hljs-string">"#"</span> <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">map</span></span> hex-str color)</span>)</span>)</span>
</code></pre>
<p>Above, we have a namespace called <code>colors</code> containing three functions called <code>hex-&gt;rgb</code>, <code>hex-str</code>, and <code>rgb-&gt;hex</code>. The functions in the same namespace can call each other directly. However, if we wanted to call these functions from a different namespace we would have to reference the <code>colors</code> namespace there first.</p>
<p>Clojure provides two ways to do this, we can either use the <code>:use</code> or the <code>:require</code> keywords. When we reference a namespace with <code>:use</code>, all its Vars become implicitly available as if they were defined in the namespace that references it.</p>
<pre><code class="lang-clojure hljs "><span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">ns</span></span> myns
  <span class="hljs-list">(<span class="hljs-attribute">:use</span> colors)</span>)</span>

<span class="hljs-list">(<span class="hljs-title">hex-&gt;rgb</span> <span class="hljs-string">"#33d24f"</span>)</span>
</code></pre>
<p>There are two downsides to this approach. We don't know where the function was originally defined, making it difficult to navigate the code, and if we reference two namespaces that use the same name for a function, we'll get an error.</p>
<p>We can address the first problem by selecting the functions we wish to use explicitly using the <code>:only</code> keyword in our <code>:use</code> declaration.</p>
<pre><code class="lang-clojure hljs "><span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">ns</span></span> myns
  <span class="hljs-list">(<span class="hljs-attribute">:use</span> <span class="hljs-collection">[colors <span class="hljs-attribute">:only</span> <span class="hljs-collection">[rgb-&gt;hex]</span>]</span>)</span>)</span>

<span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">defn</span></span> hex-str <span class="hljs-collection">[c]</span>
  <span class="hljs-list">(<span class="hljs-title">println</span> <span class="hljs-string">"I don't do much yet"</span>)</span>)</span>
</code></pre>
<p>This way we document where <code>rgb-&gt;hex</code> comes from, and we're able to declare our own <code>hex-str</code> function in  the <code>myns</code> namespace without conflicts. Note that <code>rgb-&gt;hex</code> will still use the <code>hex-str</code> function defined in the <code>colors</code> namespace.</p>
<p>The approach of using the <code>:require</code> keyword to reference the namespace provides us with more flexible options. Let's look at each of these.</p>
<p>We can require a namespace without providing any further directives. In this case, any calls to Vars inside it must be prefixed with the namespace declaration indicating their origin.</p>
<pre><code class="lang-clojure hljs "><span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">ns</span></span> myns <span class="hljs-list">(<span class="hljs-attribute">:require</span> colors)</span>)</span>

<span class="hljs-list">(<span class="hljs-title">colors/hex-&gt;rgb</span> <span class="hljs-string">"#324a9b"</span>)</span>
</code></pre>
<p>This approach is explicit about the origin of the Vars being referenced and ensures that we won't have conflicts when referencing multiple namespaces. One problem is that when our namespace declaration is long, it gets tedious to have to type it out any time we wish to use a function declared inside it. To address this problem, the <code>:require</code> statement provides the <code>:as</code> directive, allowing us to create an alias for the namespace.</p>
<pre><code class="lang-clojure hljs "><span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">ns</span></span> myotherns
  <span class="hljs-list">(<span class="hljs-attribute">:require</span> <span class="hljs-collection">[colors <span class="hljs-attribute">:as</span> c]</span>)</span>)</span>

<span class="hljs-list">(<span class="hljs-title">c/hex-&gt;rgb</span> <span class="hljs-string">"#324a9b"</span>)</span>
</code></pre>
<p>We can also require functions from a namespace by using the <code>:refer</code> keyword. This is synonymous with the <code>:use</code> notation we saw earlier. To require all the functions from another namespace, we can write the following:</p>
<pre><code class="lang-clojure hljs "><span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">ns</span></span> myns
  <span class="hljs-list">(<span class="hljs-attribute">:require</span> <span class="hljs-collection">[colors <span class="hljs-attribute">:refer</span> <span class="hljs-attribute">:all</span>]</span>)</span>)</span>
</code></pre>
<p>If we wish to select what functions to require by name, we can instead write:</p>
<pre><code class="lang-clojure hljs "><span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">ns</span></span> myns
  <span class="hljs-list">(<span class="hljs-attribute">:require</span> <span class="hljs-collection">[colors <span class="hljs-attribute">:refer</span> <span class="hljs-collection">[rgb-&gt;hex]</span>))
</span></span></span></code></pre>
<p>As you can see, there's a number of options available for referencing Vars declared in other namespaces. If you're not sure what option to pick, then requiring the namespace by name or alias is the safest route.</p>
<h3 id="dynamic-variables">Dynamic Variables</h3>
<p>Clojure provides support for declaring dynamic variables that can have their value changed within a particular scope. Let's look at how this works.</p>
<pre><code class="lang-clojure hljs "><span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">declare</span></span> <span class="hljs-comment">^{:dynamic true}</span> *foo*)</span>

<span class="hljs-list">(<span class="hljs-title">println</span> *foo*)</span>
=&gt;#&lt;Unbound Unbound: #'bar/*foo*&gt;
</code></pre>
<p>Here we declared <code>*foo*</code> as a dynamic Var and didn't provide any value for it. When we try to print <code>*foo*</code> we get an error indicating that this Var has not been bound to any value. Let's look at how we can assign a value to <code>*foo*</code> using a binding.</p>
<pre><code class="lang-clojure hljs "><span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">defn</span></span> with-foo <span class="hljs-collection">[f]</span>
  <span class="hljs-list">(<span class="hljs-title">binding</span> <span class="hljs-collection">[*foo* <span class="hljs-string">"I exist!"</span>]</span>
    <span class="hljs-list">(<span class="hljs-title">f</span>)</span>)</span>)</span>

<span class="hljs-list">(<span class="hljs-title">with-foo</span> #<span class="hljs-list">(<span class="hljs-title">println</span> *foo*)</span>)</span> =&gt;"I exist!"
</code></pre>
<p>We set <code>*foo*</code> to a string with value "I exist!" inside the <code>with-foo</code> function. When our anonymous function is called inside with-foo we no longer get an error when trying to print its value.</p>
<p>This technique can be useful when dealing with resources such as file streams, database connections, or scoped variables. In general, the use of dynamic variables is discouraged since they make code more opaque and difficult to reason about. However, there are legitimate uses for them, and it's worth knowing how they work.</p>
<h2 id="polymorphism">Polymorphism</h2>
<p>One useful aspect of object-orientation is polymorphism, while it happens to be associated with that style it's in no way exclusive to it. Clojure provides two common ways to achieve runtime polymorphism. Let's look at each of these in turn.</p>
<h3 id="multimethods">Multimethods</h3>
<p>Multimethods provide an extremely flexible dispatching mechanism using a selector function associated with one or more methods. The multimethod is defined using <code>defmulti</code> and its methods are each defined using <code>defmethod</code>. For example, if we had different shapes and we wanted to write a multimethod to calculate the area we could do the following:</p>
<pre><code class="lang-clojure hljs "><span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">defmulti</span></span> area <span class="hljs-attribute">:shape</span>)</span>

<span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">defmethod</span></span> area <span class="hljs-attribute">:circle</span> <span class="hljs-collection">[<span class="hljs-collection">{<span class="hljs-attribute">:keys</span> <span class="hljs-collection">[r]</span>}</span>]</span>
  <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">*</span></span> Math/PI r r)</span>)</span>

<span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">defmethod</span></span> area <span class="hljs-attribute">:rectangle</span> <span class="hljs-collection">[<span class="hljs-collection">{<span class="hljs-attribute">:keys</span> <span class="hljs-collection">[l w]</span>}</span>]</span>
  <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">*</span></span> l w)</span>)</span>

<span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">defmethod</span></span> area <span class="hljs-attribute">:default</span> <span class="hljs-collection">[shape]</span>
  <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">throw</span></span> <span class="hljs-list">(<span class="hljs-title">Exception.</span> <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">str</span></span> <span class="hljs-string">"unrecognized shape: "</span> shape)</span>)</span>)</span>)</span>

<span class="hljs-list">(<span class="hljs-title">area</span> <span class="hljs-collection">{<span class="hljs-attribute">:shape</span> <span class="hljs-attribute">:circle</span> <span class="hljs-attribute">:r</span><span class="hljs-number"> 10</span>}</span>)</span>
<span class="hljs-prompt">=&gt; </span>314.1592653589793

<span class="hljs-list">(<span class="hljs-title">area</span> <span class="hljs-collection">{<span class="hljs-attribute">:shape</span> <span class="hljs-attribute">:rectangle</span> <span class="hljs-attribute">:l</span><span class="hljs-number"> 5</span> <span class="hljs-attribute">:w</span><span class="hljs-number"> 10</span>}</span>)</span>
<span class="hljs-prompt">=&gt; </span>50
</code></pre>
<p>Above, the dispatch function uses a keyword to select the appropriate method to handle each type of map. This works because keywords act as functions and when passed a map will return the value associated with them. The dispatch function can be as sophisticated as we like however:</p>
<pre><code class="lang-clojure hljs "><span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">defmulti</span></span> encounter
  <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">fn</span></span> <span class="hljs-collection">[x y]</span> <span class="hljs-collection">[<span class="hljs-list">(<span class="hljs-attribute">:role</span> x)</span> <span class="hljs-list">(<span class="hljs-attribute">:role</span> y)</span>]</span>)</span>)</span>

<span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">defmethod</span></span> encounter <span class="hljs-collection">[<span class="hljs-attribute">:manager</span> <span class="hljs-attribute">:boss</span>]</span> <span class="hljs-collection">[x y]</span>
  <span class="hljs-attribute">:promise-unrealistic-deadlines</span>)</span>

<span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">defmethod</span></span> encounter <span class="hljs-collection">[<span class="hljs-attribute">:manager</span> <span class="hljs-attribute">:developer</span>]</span> <span class="hljs-collection">[x y]</span>
  <span class="hljs-attribute">:demand-overtime</span>)</span>

<span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">defmethod</span></span> encounter <span class="hljs-collection">[<span class="hljs-attribute">:developer</span> <span class="hljs-attribute">:developer</span>]</span> <span class="hljs-collection">[x y]</span>
  <span class="hljs-attribute">:complain-about-poor-management</span>)</span>

<span class="hljs-list">(<span class="hljs-title">encounter</span> <span class="hljs-collection">{<span class="hljs-attribute">:role</span> <span class="hljs-attribute">:manager</span>}</span> <span class="hljs-collection">{<span class="hljs-attribute">:role</span> <span class="hljs-attribute">:boss</span>}</span>)</span>
<span class="hljs-prompt">=&gt; </span>:promise-unrealistic-deadlines
</code></pre>
<h3 id="protocols">Protocols</h3>
<p>Protocols allow defining an abstract set of functions that can be implemented by a concrete type. Let's look at an example protocol:</p>
<pre><code class="lang-clojure hljs "><span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">defprotocol</span></span> Foo
  <span class="hljs-string">"Foo doc string"</span>
  <span class="hljs-list">(<span class="hljs-title">bar</span> <span class="hljs-collection">[this b]</span> <span class="hljs-string">"bar doc string"</span>)</span>
  <span class="hljs-list">(<span class="hljs-title">baz</span> <span class="hljs-collection">[this]</span> <span class="hljs-collection">[this b]</span> <span class="hljs-string">"baz doc string"</span>)</span>)</span>
</code></pre>
<p>As you can see, the <code>Foo</code> protocol specifies two methods, <code>bar</code> and <code>baz</code>. The first argument to the method will be the type instance followed by its parameters. Note that the <code>baz</code> method has multiple arity. We can now create a type that implements the Foo protocol using the deftype macro:</p>
<pre><code class="lang-clojure hljs "><span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">deftype</span></span> Bar <span class="hljs-collection">[data]</span> Foo
  <span class="hljs-list">(<span class="hljs-title">bar</span> <span class="hljs-collection">[this param]</span>
    <span class="hljs-list">(<span class="hljs-title">println</span> data param)</span>)</span>
  <span class="hljs-list">(<span class="hljs-title">baz</span> <span class="hljs-collection">[this]</span>
    <span class="hljs-list">(<span class="hljs-title">println</span> <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">class</span></span> this)</span>)</span>)</span>
  <span class="hljs-list">(<span class="hljs-title">baz</span> <span class="hljs-collection">[this param]</span>
    <span class="hljs-list">(<span class="hljs-title">println</span> param)</span>)</span>)</span>
</code></pre>
<p>Here we create type <code>Bar</code> that implements protocol <code>Foo</code>. Each of its methods will print out some of the parameters passed to it. Let's see what it looks like when we create an instance of <code>Bar</code> and call its methods:</p>
<pre><code class="lang-clojure hljs "><span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">let</span></span> <span class="hljs-collection">[b <span class="hljs-list">(<span class="hljs-title">Bar.</span> <span class="hljs-string">"some data"</span>)</span>]</span>
  <span class="hljs-list">(<span class="hljs-title">.bar</span> b <span class="hljs-string">"param"</span>)</span>
  <span class="hljs-list">(<span class="hljs-title">.baz</span> b)</span>
  <span class="hljs-list">(<span class="hljs-title">.baz</span> b <span class="hljs-string">"baz with param"</span>)</span>)</span>


some data param
Bar
baz with param
</code></pre>
<p>The first method call prints out the data <code>Bar</code> was initialized with and the parameter that was passed in. The second method call prints out the object's class, while the last method call demonstrates the other arity of baz.</p>
<p>We can also use protocols to extend the functionality of existing types, including existing Java classes. For example, we can use extend-protocol to extend the <code>java.lang.String</code> class with the <code>Foo</code> protocol:</p>
<pre><code class="lang-clojure hljs "><span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">extend-protocol</span></span> Foo String
  <span class="hljs-list">(<span class="hljs-title">bar</span> <span class="hljs-collection">[this param]</span> <span class="hljs-list">(<span class="hljs-title">println</span> this param)</span>)</span>)</span>

<span class="hljs-list">(<span class="hljs-title">bar</span> <span class="hljs-string">"hello"</span> <span class="hljs-string">"world"</span>)</span>
=&gt;"hello world"
</code></pre>
<p>The above examples illustrate the basic principles of how protocols can be used to write polymorphic code. However, there are many other uses for protocols as well and I encourage you to discover these on your own.</p>
<h2 id="dealing-with-global-state">Dealing With Global State</h2>
<p>While predominantly immutable, Clojure provides support for shared mutable data via its STM functions in the standard library. The STM is used to ensure that all updates to shared mutable variables are done atomically.</p>
<p>There are two primary mutable types: the <code>atom</code> and the <code>ref</code>. The <code>atom</code> is used in cases where we need to do uncoordinated updates and the <code>ref</code> is used when we might need to do multiple updates as a transaction. Let's look at an example of defining an <code>atom</code> and using it.</p>
<pre><code class="lang-clojure hljs "><span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">def</span></span> global-val <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">atom</span></span> <span class="hljs-literal">nil</span>)</span>)</span>
</code></pre>
<p>Above, we created an <code>atom</code> called <code>global-val</code> and its current value is <code>nil</code>. We can now read its value by using the <code>deref</code> function, which returns the current value.</p>
<pre><code class="lang-clojure hljs "><span class="hljs-list">(<span class="hljs-title">println</span> <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">deref</span></span> global-val)</span>)</span> =&gt; nil
</code></pre>
<p>Since this is a common operation, there is a shorthand for <code>deref</code>: the <code>@</code> symbol:</p>
<pre><code class="lang-clojure hljs "><span class="hljs-list">(<span class="hljs-title">println</span> @global-val)</span>
</code></pre>
<p>The above code is equivalent to the preceding example.</p>
<p>Let's look at two ways of setting a new value for our <code>atom</code>. We can either use <code>reset!</code> and pass in the new value, or we can use <code>swap!</code> and pass in a function that will be used to update the current value.</p>
<pre><code class="lang-clojure hljs "><span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">reset!</span></span> global-val<span class="hljs-number"> 10</span>)</span> <span class="hljs-list">(<span class="hljs-title">println</span> @global-val)</span> =&gt;10

<span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">swap!</span></span> global-val inc)</span> <span class="hljs-list">(<span class="hljs-title">println</span> @global-val)</span> =&gt;11
</code></pre>
<p>
Note that both <code>swap!</code> and <code>reset!</code> end in an exclamation point <code>!</code>; this is a convention to indicate that these functions modify mutable data.</p>
<p>We define refs the same way we define atoms, but the two are used rather differently. Let's take a quick look at how they work below.</p>
<pre><code class="lang-clojure hljs "><span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">def</span></span> names <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">ref</span></span> <span class="hljs-collection">[]</span>)</span>)</span>

<span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">dosync</span></span>
  <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">ref-set</span></span> names <span class="hljs-collection">[<span class="hljs-string">"John"</span>]</span>)</span>
  <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">alter</span></span> names #<span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">if</span></span> <span class="hljs-list">(<span class="hljs-title">not-empty</span> %)</span>
                  <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">conj</span></span> % <span class="hljs-string">"Jane"</span>)</span> %)</span>)</span>)</span>
</code></pre>
<p>In this code, we define a <code>ref</code> called <code>names</code>, then open a transaction using the <code>dosync</code> statement. Inside the transaction we set <code>names</code> to a vector with the value <code>"John"</code>. Next, we call <code>alter</code> to check if <code>names</code> is not empty and add <code>"Jane"</code> to the vector of the names if that's the case.</p>
<p>Note that since this is happening inside a transaction, the check for emptiness depends on the existing state along with any state built up within the same transaction. If we tried to add or remove a name in a different transaction, it would have no visible effect on ours. In case of a collision, one of the transactions would end up being retried.</p>
<h2 id="writing-code-that-writes-code">Writing Code That Writes Code</h2>
<p>Clojure, being a Lisp, provides a powerful macro system. Macros allow templating repetitive blocks of code and deferring evaluation, among numerous other uses. A macro works by treating code as data instead of evaluating it. This allows us to manipulate the code tree just like any other data structure.</p>
<p>Macros execute before compile time and the compiler sees the result of macro execution. Because of this level of indirection, macros can be difficult to reason about, and thus it's best not to use them when a function will do the job.</p>
<p>Let's look at a concrete example of a macro and see how it differs from the regular code we saw previously. Imagine that we have a web application with a session atom that might contain a user. We might want to load certain content only if a user is present in the session and not otherwise.</p>
<pre><code class="lang-clojure hljs "><span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">def</span></span> session <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">atom</span></span> <span class="hljs-collection">{<span class="hljs-attribute">:user</span> <span class="hljs-string">"Bob"</span>}</span>)</span>)</span>

<span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">defn</span></span> load-content <span class="hljs-collection">[]</span>
  <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">if</span></span> <span class="hljs-list">(<span class="hljs-attribute">:user</span> @session)</span>
    <span class="hljs-string">"Welcome back!"</span>
    <span class="hljs-string">"please log in"</span>)</span>)</span>
</code></pre>
<p>This will work, but it's tedious and error-prone to write out the <code>if</code> statement every single time. Since our condition's logic stays the same, we can template this function as follows:</p>
<pre><code class="lang-clojure hljs "><span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">defmacro</span></span> defprivate <span class="hljs-collection">[name args &amp; body]</span>
  `<span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">defn</span></span> ~<span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">symbol</span></span> name)</span> ~args
     <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">if</span></span> <span class="hljs-list">(<span class="hljs-attribute">:user</span> @session)</span>
       <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">do</span></span> ~@body)</span>
       <span class="hljs-string">"please log in"</span>)</span>)</span>)</span>
</code></pre>
<p>The macros are defined using the <code>defmacro</code> special form. The major difference between <code>defn</code> and <code>defmacro</code> is that the parameters passed to <code>defmacro</code> are not evaluated by default.</p>
<p>To evaluate the parameter we use the <code>~</code>, as we're doing with <code>~(symbol name)</code>. Using the <code>~</code> notation indicates that we'd like to replace the name with the value it refers to. This is called unquoting.</p>
<p>The <code>~@</code> notation used in <code>(do ~@body)</code> is called unquote splicing. This notation is used when we're dealing with a sequence. The contents of the sequence will be merged into the outer form during the splicing. In this case the body consists of a list representing the function's body. The body must be wrapped in a <code>do</code> block because the <code>if</code> statement requires having no more than three arguments.</p>
<p>The <code>`</code> sign means that we wish to treat the following list as data instead of executing it. This is the opposite of unquoting, and it's referred to as syntax-quoting.</p>
<p>As I mentioned earlier, the macros are executed before compile time. To see what the macro will be rewritten as when the compiler sees it, we can call <code>macroexpand-1</code>.</p>
<pre><code class="lang-clojure hljs "><span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">macroexpand-1</span></span> '<span class="hljs-list">(<span class="hljs-title">defprivate</span> foo <span class="hljs-collection">[greeting]</span> <span class="hljs-list">(<span class="hljs-title">println</span> greeting)</span>)</span>)</span>

<span class="hljs-list">(<span class="hljs-title">clojure.core/defn</span> foo <span class="hljs-collection">[greeting]</span>
  <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">if</span></span> <span class="hljs-list">(<span class="hljs-attribute">:user</span> <span class="hljs-list">(<span class="hljs-title">clojure.core/deref</span> session)</span>)</span>
    <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">do</span></span> <span class="hljs-list">(<span class="hljs-title">println</span> greeting)</span>)</span>
    <span class="hljs-string">"please log in"</span>)</span>)</span>
</code></pre>
<p>We can see that <code>(defprivate foo (println "bar"))</code> gets rewritten with a function definition that has the <code>if</code> statement inside. This resulting code is what the compiler will see, and it's equivalent to what we would have to write by hand otherwise. Now we can simply define a private function using our macro, and it will do the check for us automatically.</p>
<pre><code class="lang-clojure hljs "><span class="hljs-list">(<span class="hljs-title">defprivate</span> foo <span class="hljs-collection">[message]</span> <span class="hljs-list">(<span class="hljs-title">println</span> message)</span>)</span>

<span class="hljs-list">(<span class="hljs-title">foo</span> <span class="hljs-string">"this message is private"</span>)</span>
</code></pre>
<p>The preceding example might seem a little contrived, but it demonstrates the power of being able to easily template repetitions in code. This allows creating a notation that expresses your problem domain using the language that is natural to it.</p>
<h2 id="the-read-evaluate-print-loop">The Read-Evaluate-Print Loop</h2>
<p>Another big aspect of working in Clojure is the read-evaluate-print loop (REPL). In many languages you write the code, then run the entire program to see what it does. In Clojure, most development is done interactively using the REPL. In this mode we can see each piece of code we write in action as soon as it's written.</p>
<p>In nontrivial applications it's often necessary to build up a particular state before you can add more functionality. For example, a user has to log in and query some data from the database, then you need to write functions to format and display this data. With a REPL you can get the application to the state where the data is loaded and then write the display logic interactively without having to reload the application and build up the state every time you make a change.</p>
<p>This method of development is particularly satisfying because you see immediate feedback when making changes. You can easily try things out and see what approach works best for the problem you're solving. This encourages experimentation and refactoring code as you go, which in turn helps you to write better and cleaner code.</p>
<h2 id="calling-out-to-java">Calling Out to Java</h2>
<p>One last thing that we'll cover is how Clojure embraces its host platform to benefit from the rich ecosystem of existing Java libraries. In some cases we may wish to call a Java library to accomplish a particular task that doesn't have a native Clojure implementation. Calling Java classes is very simple, and follows the standard Clojure syntax fairly closely.</p>
<h3 id="importing-classes">Importing Classes</h3>
<p>When we wish to use a Clojure namespace, we employ either the <code>:use</code> or the <code>:require</code> statements discussed above. However, when we wish to import a Java class, we have to use the <code>:import</code> statement instead:</p>
<pre><code class="lang-clojure hljs "><span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">ns</span></span> myns
  <span class="hljs-list">(<span class="hljs-attribute">:import</span> java.io.File)</span>)</span>
</code></pre>
<p>We can also group multiple classes from the same package in a single import, as follows:</p>
<pre><code class="lang-clojure hljs "><span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">ns</span></span> myns
  <span class="hljs-list">(<span class="hljs-attribute">:import</span> <span class="hljs-collection">[java.io File FileInputStream FileOutputStream]</span>)</span>)</span>
</code></pre>
<h3 id="instantiating-classes">Instantiating Classes</h3>
<p>To create an instance of a class, we can call new just as we would in Java:</p>
<pre><code class="lang-clojure hljs "><span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">new</span></span> File <span class="hljs-string">"."</span>)</span>
</code></pre>
<p>There is also a commonly used shorthand for instantiating objects:</p>
<pre><code class="lang-clojure hljs "><span class="hljs-list">(<span class="hljs-title">File.</span> <span class="hljs-string">"."</span>)</span>
</code></pre>
<h3 id="calling-methods">Calling Methods</h3>
<p>Once we have an instance of a class, we can start calling methods on it. The notation is similar to making a regular function call. When we call a method, we pass the object as its first parameter followed by any other parameters that the method accepts.</p>
<pre><code class="lang-clojure hljs "><span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">let</span></span> <span class="hljs-collection">[f <span class="hljs-list">(<span class="hljs-title">File.</span> <span class="hljs-string">"."</span>)</span>]</span>
  <span class="hljs-list">(<span class="hljs-title">println</span> <span class="hljs-list">(<span class="hljs-title">.getAbsolutePath</span> f)</span>)</span>)</span>
</code></pre>
<p>Above, we created a new file object <code>f</code>, and then called the <code>.getAbsolutePath</code> method on it. Notice that methods have a period <code>.</code> in front of them to differentiate them from a regular Clojure function. If we wanted to reference a static method or a variable in a class, we would use the <code>/</code> notation instead:</p>
<pre><code class="lang-clojure hljs "><span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">str</span></span> File/separator <span class="hljs-string">"foo"</span> File/separator <span class="hljs-string">"bar"</span>)</span>

<span class="hljs-list">(<span class="hljs-title">Math/sqrt</span><span class="hljs-number"> 256</span>)</span>
</code></pre>
<p>There's also a shorthand for chaining multiple method calls together using the <code>..</code> notation. Say we wanted to get the string indicating the file path and then get its bytes; we could write the code for that in two ways.</p>
<pre><code class="lang-clojure hljs "><span class="hljs-list">(<span class="hljs-title">.getBytes</span> <span class="hljs-list">(<span class="hljs-title">.getAbsolutePath</span> <span class="hljs-list">(<span class="hljs-title">File.</span> <span class="hljs-string">"."</span>)</span>)</span>)</span>

<span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">..</span></span> <span class="hljs-list">(<span class="hljs-title">File.</span> <span class="hljs-string">"."</span>)</span> getAbsolutePath getBytes)</span>
</code></pre>
<h2 id="further-reading">Further Reading</h2>
<p>This concludes our tour of Clojure basics. While we only touched on only a small portion of the overall language, I hope that the guide has provided you with a bit of insight into how idiomatic Clojure code is written. Below are some useful links for more in-depth documentation about the language.</p>
<ul>
<li><a href="http://clojure.org/documentation">Official Clojure documentation</a></li>
<li><a href="http://www.braveclojure.com/">Clojure for the Brave and True</a></li>
<li><a href="http://clojure-doc.org/">Community Clojure documentation site</a></li>
<li><a href="http://www.braveclojure.com/">A humorous introduction to Clojure</a></li>
<li><a href="http://grimoire.arrdem.com/">Clojure API documentation</a></li>
<li><a href="http://clojure.org/cheatsheet">Clojure cheatsheet</a></li>
<li><a href="https://github.com/bbatsov/clojure-style-guide">Clojure style guide</a></li>
</ul>

<p>
Copyright &copy; <span id="year">2015</span> Dmitri Sotnikov
</p>
</div>
<script type="text/javascript">
    document.getElementById("year").innerHTML = new Date().getFullYear();
</script>
</body>
</html>
