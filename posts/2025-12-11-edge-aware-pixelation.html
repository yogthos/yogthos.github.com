<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="me" href="https://mastodon.social/@yogthos">
    <link rel="me" href="https://mas.to/@yogthos">
    <link rel="me" href="https://social.marxist.network/@yogthos">
    <title>(iterate think thoughts): Edge-Aware Pixelation for Better Pixel Art</title>
    <meta name="description" content="Dmitri&#39;s blog about programming, Clojure, and software development">
    <meta name="keywords" content="">
    <meta content="width=device-width, initial-scale=1" name="viewport">
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="icon" type="image/png" href="/img/favicon.png">
    <link href="/css/site.css" rel="stylesheet" type="text/css" />
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css" media="(prefers-color-scheme: light)" id="hljs-light">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/base16/tomorrow-night.min.css" media="(prefers-color-scheme: dark)" id="hljs-dark">
    <script>
    (function(){var t=localStorage.getItem('theme');if(t){document.documentElement.setAttribute('data-theme',t);var l=document.getElementById('hljs-light'),d=document.getElementById('hljs-dark');if(l&&d){if(t==='dark'){l.media='not all';d.media='all'}else{l.media='all';d.media='not all'}}}})();
    </script>
</head>
<body>

<aside id="sidebar">

    <p id="logo">
        <a title="(iterate think thoughts)" href="/index.html">
            <span class="text"><span class="paren">(</span><span class="fn">iterate</span>
                <br>
                <span class="text">&nbsp;&nbsp;think</span>
                <br>
                <span class="text">&nbsp;&nbsp;thoughts<span class="paren">)</span>
            </span>
        </a>
    </p>

    <nav id="menucont" class="bodycontainer">
        <button class="menu-toggle" aria-label="Toggle menu">
            <span class="hamburger"></span>
            <span class="menu-label">Menu</span>
        </button>
        <ul class="menu">
            <li ><a title="Home" href="/index.html">Home</a></li>
            <li ><a title="Archives" href="/archives.html">Archives</a></li>
            
            <li ><a title="Tags" href="/tags.html">Tags</a></li>
            
            
            <li >
                <a href="/pages/about.html">About</a>
            </li>
            
            <li><a title="RSS" href="/feed.xml">RSS</a></li>
        </ul>
    </nav>

    <div class="theme-toggle-wrapper">
        <button class="theme-toggle" aria-label="Toggle dark mode">
            <svg class="icon-sun" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18a6 6 0 1 1 0-12 6 6 0 0 1 0 12zm0-2a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM11 1h2v3h-2V1zm0 19h2v3h-2v-3zM3.515 4.929l1.414-1.414L7.05 5.636 5.636 7.05 3.515 4.93zM16.95 18.364l1.414-1.414 2.121 2.121-1.414 1.414-2.121-2.121zm2.121-14.85l1.414 1.415-2.121 2.121-1.414-1.414 2.121-2.121zM5.636 16.95l1.414 1.414-2.121 2.121-1.414-1.414 2.121-2.121zM23 11v2h-3v-2h3zM4 11v2H1v-2h3z"/></svg>
            <svg class="icon-moon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M10 7a7 7 0 0 0 12 4.9v.1c0 5.523-4.477 10-10 10S2 17.523 2 12 6.477 2 12 2h.1A6.979 6.979 0 0 0 10 7zm-6 5a8 8 0 0 0 15.062 3.762A9 9 0 0 1 8.238 4.938 7.999 7.999 0 0 0 4 12z"/></svg>
            <span>Theme</span>
        </button>
    </div>
</aside>

<main id="content">
    
<div id="post">
    <article>
<div class="post-header">
    <div id="post-meta" class="row">
        <strong>December 11, 2025</strong>
        
    </div>
    <h1><a class="post-title" href="/posts/2025-12-11-edge-aware-pixelation.html">Edge-Aware Pixelation for Better Pixel Art</a></h1>
</div>
<div>
    
    <p>Pixelation is everywhere these days, from retro game aesthetics to modern design trends. But if you've ever tried to create pixel art from a photograph, you've probably noticed that the results often look a bit off. Edges get jagged, important features get distorted, and the whole image tends to lose its character.</p><p>Most pixelation algorithms rely on the same approach of downscaling the image, then upscaling it back. While this is fast and cheap to implement, it treats every part of the image the same way forcing a rigid grid that cuts indiscriminately across edges, faces, and fine details.</p><p>In this post, we'll take a look at a strategy of using edge-aware pixelation. The idea here is to use an algorithm that adapts to the structure of the image rather than forcing a uniform grid onto it. We'll look at how it works, why it tends to produce better results, and the trade-offs involved.</p><h3 id="the&#95;traditional&#95;approach">The Traditional Approach</h3><p>Let's start by looking at what most pixelation libraries do under the hood. The most common approach uses standard image scaling with smoothing.</p><pre><code class="javascript">// Pseudo-code for traditional pixelation
const downscaled = scaleDown&#40;image, pixelSize&#41;; // Uses bilinear/bicubic
const pixelated = scaleUp&#40;downscaled, originalSize&#41;; // Nearest-neighbor
</code></pre><p>While this works, there are a few obvious problems. Smoothing filters tend to blur important edges before downsampling, and the pixel grid doesn't care about the image content. This often leads to artifacts where edges get "chopped" across pixel boundaries, creating jagged lines. You also end up losing fine features like eyes or text.</p><p>Some approaches try to improve on this using median color sampling instead of averaging.</p><pre><code class="javascript">// Sample colors in each block, pick median
const blockColor = median&#40;colorsInBlock&#41;;
</code></pre><p>This avoids some of the blurring, but it still suffers from the same fixed grid issue. It ignores the image structure and can create harsh transitions between blocks.</p><p>Basically, all these methods force a uniform grid onto the image without considering its content. The result is usually pixel blocks that cut across important features. For example, if we use the following <a href='https://commons.wikimedia.org/wiki/File:CANADAMIKE.jpg'>image from wikimedia</a> as the input.</p><p><img src="/img/pixelation/CANADAMIKE.jpg" alt="stock portrait" /></p><p>The result ends up looking something like the following when using a naive pixelation algorithm:</p><p><img src="/img/pixelation/pixelated-naive.png" alt="Naive pixelation" /></p><h3 id="edge-aware&#95;adaptive&#95;grid">Edge-Aware Adaptive Grid</h3><p>Instead of forcing a rigid grid, we can let the grid adapt to the image. This is the core idea behind edge-aware pixelation. We can treat pixelation as an optimization problem with four main stages.</p><h4 id="1&#46;&#95;edge&#95;detection">1&#46; Edge Detection</h4><p>First, we need to understand where the important features are in the image.</p><pre><code class="javascript">// Sobel operators detect gradient magnitude and direction
const gradient = calculateGradient&#40;image&#41;;
const edges = applyNonMaximumSuppression&#40;gradient&#41;;
const edgeMap = thresholdEdges&#40;edges, sharpness&#41;;
</code></pre><p>We use Sobel operators to compute the gradient magnitude, and then apply non-maximum suppression to thin the edges to a single-pixel width. Finally, we use percentile-based thresholding to adapt to the edge distribution of the specific image. Since this can be computationally expensive, using WebGL can provide a significant speedup here.</p><p>This gives us an edge map where bright pixels represent edges and dark pixels represent smooth regions.</p><p><img src="/img/pixelation/edges.png" alt="Sobel edges" /></p><h4 id="2&#46;&#95;grid&#95;initialization">2&#46; Grid Initialization</h4><p>Next, we start with a regular grid matching the target pixel size.</p><pre><code class="javascript">const grid = createUniformGrid&#40;width, height, pixelSize&#41;;
</code></pre><p>Unlike traditional methods, the grid is just a starting point. Each cell is defined by four corner points which we can move around.</p><p><img src="/img/pixelation/grid.png" alt="Initial grid" /></p><h4 id="3&#46;&#95;grid&#95;optimization">3&#46; Grid Optimization</h4><p>This is where the actual work happens. We iteratively move the grid corners to align the cell boundaries with the detected edges.</p><pre><code class="javascript">for &#40;let iteration = 0; iteration &lt; numIterations; iteration++&#41; {
  for &#40;each corner in grid&#41; {
    // Search nearby positions
    const candidates = searchNeighborhood&#40;corner, stepSize&#41;;

    // Evaluate how well each position aligns edges
    for &#40;const candidate of candidates&#41; {
      const score = evaluateEdgeAlignment&#40;candidate, edgeMap&#41;;
      if &#40;score &gt; bestScore&#41; {
        bestPosition = candidate;
      }
    }

    // Move corner toward best position &#40;with damping&#41;
    corner.moveToward&#40;bestPosition, damping&#41;;
  }
}
</code></pre><p>For each corner, we test multiple positions in a local neighborhood and evaluate the alignment by sampling edge strength along the grid edges. We want to find positions where the grid boundaries follow the edges continuously. We also use damping to prevent over-optimization and maintain stability.</p><p>The result is a grid that bends and adapts to align with the natural structure of the image.</p><p><img src="/img/pixelation/optimized-grid.png" alt="Optimized grid" /></p><h4 id="4&#46;&#95;color&#95;assignment">4&#46; Color Assignment</h4><p>Finally, we need to assign colors to our optimized cells.</p><pre><code class="javascript">for &#40;each cell in grid&#41; {
  const pixels = samplePixelsInCell&#40;cell&#41;;

  // Blend between average &#40;soft&#41; and median &#40;crisp&#41; based on edge presence
  if &#40;cell.hasEdges&#41; {
    color = blend&#40;average&#40;pixels&#41;, median&#40;pixels&#41;, sharpness&#41;;
  } else {
    color = average&#40;pixels&#41;; // Smooth regions use average
  }

  renderCell&#40;cell, color&#41;;
}
</code></pre><p>Here we can use a blending strategy. For smooth regions, we use the average color for natural blending. For edge regions, we can blend between average and median based on the desired sharpness. This lets us tune the aesthetic from soft, blended edges to crisp, high-contrast ones. Looking at the two methods side by side, we can see how much smoother the resulting image is:</p><p><table border="0"> <tr><th>Edge detection</th><th>Naive</th></tr> <tr><td><img src="/img/pixelation/pixelated-edges.png" alt="Edge detected pixelation" /></td><td><img src="/img/pixelation/pixelated-naive.png" alt="Naive pixelation" /></td></tr> </table></p><h3 id="discussion">Discussion</h3><p>There are several advantages to this approach. The most obvious is edge preservation. Traditional methods create jagged artifacts because pixel boundaries cut across edges. By aligning the grid boundaries with the edges, we can preserve continuity and create smoother transitions.</p><p>This also means we don't get those choppy edges on outlines, and we can preserve fine details like facial features or text much better. The algorithm effectively has some semantic awareness of what's important in the image.</p><p>However, there are trade-offs to consider. The adaptive grid and color blending can produce softer edges compared to traditional methods. If you're looking for extremely crisp, high-contrast pixel art with hard edges, like what you'd see in retro games, traditional downsampling might actually be a better fit.</p><p>You also get less contrast in some cases. The color blending can reduce the overall "punchiness" compared to median sampling.</p><p>Performance is another factor. Edge-aware pixelation is computationally more intensive. You have to handle edge detection, iterative grid optimization, and spatial hashing for rendering. While WebGL optimizations make it practical taking 100-500ms on most images, simple downsampling will always be faster.</p><p>I've found that edge-aware pixelation works best for photographs, portraits, and complex scenes where preserving structure is important. It's less ideal for abstract art or images where a uniform grid is desired for stylistic reasons.</p><h3 id="conclusion">Conclusion</h3><p>By detecting edges and optimizing alignment, edge-aware pixelation produces pixel art that does a good job of preserving the essence of the original while still achieving low-resolution aesthetic.</p><p>If you're interested in trying this out live <a href='https://yogthos.net/pixel-mosaic.html'>here</a>, and all the code is available as an open source library called <a href='https://github.com/yogthos/pixel-mosaic'>Pixel Mosaic</a> that implements both traditional and edge-aware pixelation.</p><p>I hope this gives you some ideas for your own image processing projects. Sometimes the simple method is enough, but for complex images, the extra effort of edge-aware processing can be well worth it.</p>
</div>

<div id="post-tags">
    <br/>
    <b>Tags: </b>
    
    <a href="/graphics.html">graphics</a>
    
    <a href="/programming.html">programming</a>
    
    <a href="/javascript.html">javascript</a>
    
</div>

<br/>
</article>

    <div id="prev-next">
        
        <a class="button" href="/posts/2026-01-12-recursive-language-model.html">&laquo; Grounding LLMs with Recursive Code Execution</a>
        
        
        <a class="right button" href="/posts/2023-06-10-disagreement.html">Role of Debate in Problem Solving &raquo;</a>
        
    </div>

    


</div>

    <hr/>
    <footer id="footercont">Copyright &copy; 2026 Dmitri Sotnikov
        <p>Powered by <a href="http://cryogenweb.org">Cryogen</a></p>
    </footer>
</main>

<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="/js/scripts.js" type="text/javascript"></script>


</body>
</html>
